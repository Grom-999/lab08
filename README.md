# lab08

## Tasks

- [ ] 1. Создать публичный репозиторий с названием **lab08** на сервисе **GitHub**
- [ ] 2. Ознакомиться со ссылками учебного материала
- [ ] 3. Выполнить инструкцию учебного материала
- [ ] 4. Составить отчет и отправить ссылку личным сообщением в **Slack**

## description


Создаем образ для Docker (Образы Docker являются результатом процесса их сборки, а контейнеры Docker — это выполняющиеся образы.)
```sh
$ cat > Dockerfile <<EOF
FROM ubuntu:18.04
EOF
```
```sh
FROM — задаёт базовый (родительский) образ.
```
Устанавливаем компиляторы и cmake
```sh
$ cat >> Dockerfile <<EOF

RUN apt update
RUN apt install -yy gcc g++ cmake
EOF
```
Копируем все полученные файлы в новую директорию print и делаем ее активной
```sh
$ cat >> Dockerfile <<EOF

COPY . print/
WORKDIR print
EOF
```
```sh
 COPY сообщает Docker о том, что нужно взять файлы и папки из локального контекста сборки
 и добавить их в текущую рабочую директорию образа.
 Если целевая директория не существует, эта инструкция её создаст.
```
```sh
Инструкция WORKDIR позволяет изменить рабочую директорию контейнера. С этой директорией работают инструкции
COPY, ADD, RUN, CMD и ENTRYPOINT, идущие за WORKDIR.
```
Выполняем сборку нашего приложения
```sh
$ cat >> Dockerfile <<EOF

RUN cmake -H. -B_build -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=_install
RUN cmake --build _build
RUN cmake --build _build --target install
EOF
```
Добавляем переменную среду
```sh
$ cat >> Dockerfile <<EOF

ENV LOG_PATH /home/logs/log.txt
EOF
```
```sh
Инструкция ENV позволяет задавать постоянные переменные среды,
которые будут доступны в контейнере во время его выполнения. 
```
Указываем место, которое контейнер будет использовать для постоянного хранения файлов и для работы с такими файлами
```sh
$ cat >> Dockerfile <<EOF

VOLUME /home/logs
EOF
```
```sh
VOLUME — создаёт точку монтирования для работы с постоянным хранилищем.
```
 устанавливаем рабочую директорию
 ```sh
$ cat >> Dockerfile <<EOF

WORKDIR _install/bin
EOF
```
Запускаем исполняемый файл приложения
```sh
$ cat >> Dockerfile <<EOF

ENTRYPOINT ./demo
EOF
```
```sh
Инструкция ENTRYPOINT позволяет задавать команду с аргументами, которая должна выполняться при запуске контейнера.
Она похожа на команду CMD, но параметры, задаваемые в ENTRYPOINT, не перезаписываются в том случае, если контейнер 
запускают с параметрами командной строки.
```
Собираем образ
```sh
$ docker build -t logger .
```
просматриваем доступные образы
```sh
$ docker images
```
Вызов нашей программы из образа
```sh
$ mkdir logs
$ docker run -it -v "$(pwd)/logs/:/home/logs/" logger
#Вводим текст и жмем CTRL-D
```
```sh
Если перед флагом стоит два тире — то это его полная форма, флаг с одним тире — это сокращённый вариант некоего флага.
Действуют они одинаково. Например, -p — это сокращённая форма флага --port.

Флаг -i — это сокращение для --interactive. Благодаря этому флагу поток STDIN поддерживается в открытом состоянии даже
если контейнер к STDIN не подключён.

Флаг -t — это сокращение для --tty. Благодаря этому флагу выделяется псевдотерминал, который соединяет используемый
терминал с потоками STDIN и STDOUT контейнера.

Для того чтобы получить возможность взаимодействия с контейнером через терминал нужно совместно использовать флаги
-i и -t.

Флаг -p представляет собой сокращение для --port. Порт — это интерфейс, благодаря которому контейнер взаимодействует 
с внешним миром. Конструкция 1000:8000 перенаправляет порт Docker 8000 на порт 1000 компьютера, на котором выполняется
контейнер. Если в контейнере работает некое приложение, способное выводить что-то в браузер, то, для того, чтобы к нему
обратиться, в нашем случае можно перейти в браузере по адресу localhost:1000.

Флаг --rm автоматически удаляет контейнер после того, как его выполнение завершится.

Флаг -d — это сокращение для --detach. Эта команда запускает контейнер в фоновом режиме.
Это позволяет использовать терминал, из которого запущен контейнер, для выполнения других команд во время работы контейнера.
```
просмотр состояния образа
```sh
$ docker inspect logger
```
просмотим наш текст в лог для проверки
```sh
$ cat logs/log.txt
```
Создадим .yml файл для создания образа
```sh
$ vim .travis.yml
/lang<CR>o
services:
- docker<ESC>
jVGdo
script:
- docker build -t logger .<ESC>
:wq
```
добавляем и пушим все изменений
```sh
$ git add Dockerfile
$ git add .travis.yml
$ git commit -m"adding Dockerfile"
$ git push origin master
```
устанавливаем автоматический вход в гит хаб
```sh
$ travis login --auto
$ travis enable
```
